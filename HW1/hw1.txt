All SET functions take lists, a & b, representing sets
SUBSET:
	OUT: bool representing if a is a subset of b
	base case: the former is empty, so return true
	inductive case: if a[0] is in b, return (subset (rest of a) b)
				if not, return false

EQUAL SETS:
	OUTPUT: bool representing if the sets are equivalent
	return whether both are subsets of each other


SET UNION:
	OUT: a list representing the union of the two sets
	if a is empty, return b
	else if a[0] a is in b, return (union (rest of a) b)
	else return the first element of a::the recursive call

SET INTERSECTION:
	OUT: a list representing the intersection of the two sets
	if a is empty, so return []
	else if a[0] is in b, return a[0]::(intersection (rest of a) b)
	else return (intersection (rest of a) b)

SET DIFF:
	OUT: a list representing the difference between the two sets (a - b)
	if a is empty, so return []
	else if a[0] is in b, return (difference (rest of a) b)
	else return a[0]::(difference (rest of a) b)

COMPUTED FIXED POINT:
	IN: equality function eq, function f, first input value x
	OUT: a value v of the same type as the input value st (f v) = v
		this may loop infinitely if there is no solution
	if f(input value) = input value, return input value
	else return COMPUTED FIXED POINT eq f output value


FILTER REACHABLE:
	IN: a pair (rt, rules) representing a grammar
	OUT: a pair (rt, new rules) where new rules is the reachable subset of rules
	if rules contains no more branches for rt; return rules
	else:	get a rule branching from rt 
		get the nonterminal subset of rule's expression
		clip the rule tree at this branch
		recursive call on each symbol in the expr
		combine resulting rule trees
		merge combined subtree with recursive call on rt
		return (rt, set_intersection tree combined_tree)

	The following defined subroutines are used:
		make_grammar nodes tree:	return list (for node in nodes make (node, tree))
		filter_and_stick_subtrees:	merge results of filtering operand w/ tree