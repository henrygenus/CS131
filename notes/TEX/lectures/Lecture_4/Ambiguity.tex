\documentclass[../../lecture_notes.tex]{subfiles}

\begin{document}
\newcommand*{\equal}{=}

\noindent Consider a simple grammar:\\
	\indent E $\rightarrow$ E + E\\
	\indent E $\rightarrow$ E * E\\
	\indent E $\rightarrow$ (E)\\
	\indent E $\rightarrow$ id\\
This has an ambiguity, as can be seen by the two parse trees below: 
\begin{center} \begin{tikzpicture}
	% tree 1
		\node (1){E} 
			child {node {E}
				child {node {E}
					child{node {a}
						edge from parent node {}
					}
					edge from parent node {}
				}
				child {node [circle, draw] {}
					child{node {+}
						edge from parent node {}
					}
					edge from parent node {}
				}
				child {node [circle, draw] {}
					child{node {b}
						edge from parent node {}
					}
					edge from parent node {}
				}
				edge from parent node {}
			}
			child [missing]
			child {node[circle, draw] {}
				child {node [circle, draw] {}
						child{node {*}
							edge from parent node {}
						}
						edge from parent node {}
					}
				edge from parent node {}
			}
			child {node[circle, draw] {}
				child {node {E}
						child{node {c}
							edge from parent node {}
						}
						edge from parent node {}
				edge from parent node {}
				}
			};
	% tree 2
		\node [right =5cm of  1] {E} 
			child {node[circle, draw] {}
				child {node {E}
						child{node {a}
							edge from parent node {}
						}
						edge from parent node {}
					}
				edge from parent node {}
			}
			child {node[circle, draw] {}
				child {node [circle, draw] {}
						child{node {*}
							edge from parent node {}
						}
						edge from parent node {}
					}
				edge from parent node {}
			}
			child [missing]
			child {node {E}
				child {node {E}
					child{node {b}
						edge from parent node {}
					}
					edge from parent node {}
				}
				child {node [circle, draw] {}
					child{node {+}
						edge from parent node {}
					}
					edge from parent node {}
				}
				child {node {E}
					child{node {c}
						edge from parent node {}
					}
					edge from parent node {}
				}
				edge from parent node {}
			};
\end{tikzpicture} \end{center}
\noindent Parsers will build the left tree, whereas humans would build the right.\\
We must complicate the grammar to filter out the bad trees.\\
	\indent E $\rightarrow$ E * T\\
	\indent E $\rightarrow$ E + T\\
	\indent E $\rightarrow$ T\\
	\indent E $\rightarrow$ (E)\\
	\indent E $\rightarrow$ id\\
Now we have a single correct tree:
\begin{center} \begin{tikzpicture}
		\node {E} 
			child {node[circle, draw] {}
				child {node {T}
						child{node {a}
							edge from parent node {}
						}
						edge from parent node {}
					}
				edge from parent node {}
			}
			child {node[circle, draw] {}
				child {node [circle, draw] {}
						child{node {+}
							edge from parent node {}
						}
						edge from parent node {}
					}
				edge from parent node {}
			}
			child [missing]
			child {node {E}
				child {node {T}
					child{node {b}
						edge from parent node {}
					}
					edge from parent node {}
				}
				child {node [circle, draw] {}
					child{node {*}
						edge from parent node {}
					}
					edge from parent node {}
				}
				child {node {T}
					child{node {c}
						edge from parent node {}
					}
					edge from parent node {}
				}
				edge from parent node {}
			};
\end{tikzpicture} \end{center}
Our edits specify two new properties: \begin{enumerate} 
	\item (*) has higher precedence than (+)
	\item both (*) and (+) are left-associative
\end{enumerate}
Let's now look at a subset of C's grammar:\\
	\indent smt:\\
		\indent \indent ';'\\
		\indent \indent 'break' ';'\\
		\indent \indent 'return' ';'\\
		\indent \indent 'return' expr ';'\\
		\indent \indent expr ';'\\
		\indent \indent 'goto' 'ID' ';'\\
		\indent \indent 'ID' ';' stmt\\
		\indent \indent 'while' '(' expr ')' stmt\\
		\indent \indent 'do' stmt 'while' '(' expr ')' ';'\\
		\indent \indent 'if' '(' expr ')' stmt\\
		\indent \indent 'if' '(' expr ')' stmt 'else' stmt\\ \\
We may naturally wonder why some of these choices were made; for instance -- why parentheses?\\
Consider the following altered right-hand-sides \begin{enumerate}
	\item 'while' expr stmt:\\
		This is ambiguous -- consider while i * p = = 3;
	\item 'do' stmt 'while' expr ';'\\
		This is not ambiguous, since we know where our expr ends.  Parentheses are used for consistency.
\end{enumerate}
Not all ambiguities are as obvious as our original example, however; this C sub-grammar even has one!\\
It is one we have undoubtedly encountered.... The dangling else!\\
Consider the following two trees:
\begin{center} \begin{forest}
	 forked edges,
	[E
		[if]
		[(]
		[E 
			[a \equal\equal b]
		]
		[)]
		[E 
			[if]
			[(]
			[E 
				[c \equal\equal d]
			]
			[)]
			[E
				[return]
				[a/c]
				[;]
			]
		]
		[E
			[else
				[E
					[return]
					[d]
					[;]
				]
			]
		]
	]
	\end{forest} \begin{forest}
	 forked edges,
	[E
		[if]
		[(]
		[E 
			[a \equal\equal b]
		]
		[)]
		[E 
			[if]
			[(]
			[E 
				[c \equal\equal d]
			]
			[)]
			[E
				[return]
				[a/c]
				[;]
			]
			[else
				[E
					[return]
					[d]
					[;]
				]
			]
		]
	];
\end{forest} \end{center}
We know the latter is correct, but what rule is causing this?\\
As it turns out.. 'if '(' expr ')' stmt 'else' stmt \textit{is too generous!}\\
We could fix this by adding a <full-stmt> nonterminal that requires an else, but C doesn't.\\
To see why, we must consider the following two trees for the statement a + b * c + d:\\ \\
\begin{figure}[H]
\begin{minipage}[label=ab]{0.5\linewidth} 
\begin{forest}
	[E
		[ [a]]
		[ [+]]
		[E
			[b]
			[*]
			[c]]
		[ [+]]
		[ [d]]]
\end{forest}  \end{minipage}%
\begin{minipage}[cd]{0.5\linewidth} \begin{forest}
		[E
			[E 
				[T [a]]
			]
			[+]
			[T
				[T [b]]
				[*]
				[T [c]]
			]
		]
		[+]
		[T 
			[d]
		]
	]
\end{forest} \end{minipage} \end{figure}
\noindent The left tree is an \textbf{\underline{abstract parse tree}}, 
	which uses an ambiguous grammar and smart compiler.\\
The right tree is a \textbf{\underline{concrete parse tree}}, since its grammar is unambiguous.\\
Since abstract parse trees are smaller and simpler, the C compiler uses the abstract tree.\\
The C standard thus leaves fixing the ambiguity to the programmer, in "the usual way".\\
\\
For an example of ambiguity, consider Prolog:\\
Prolog lets us define operators in the form :- op(precedence, associativity, [operators]),\\
	where lower precedence means operating first, and y is the associative parameter.
Thus: \begin{lstlisting}[language=Prolog]
:-op(500, yfx, [+, -]).
:-op(400, yfx, [*, /]).
% so for a*b*c -> (a+b)*c, we violate (*)'s precedence and associativity! 
:-op(200, xfy, [**]).
:-op(200, fy, [+, -]).
/*	Therefore: 
	a**b**c -> a**(b**c)
	a**(-b) -> -b**a -> -(b**a) */
:-op(700, xfx, [=, >=,...]).
% these are non associative ^^^ so a==b==c is an error!
if (a <= b <= c) ...; % valid code! but translates to
if ((a<=b) <= c)...; % which is equivalent to
if ([0,1] <= c)...; % which is not the expected behavior!
\end{lstlisting}
Ambiguity is not the only runtime error we may face though; consider the following C code:
\begin{lstlisting}[language=C]
int a, b;
int f(void) {return (a=1) + (b=2);}
// this is valid & harmless, albeit pointless, BUT
int g(void) {return (a=1) + (a=2);}
// this is undefined behavior in C!
// it could change a to 15, or return 42, or even dump core!
\end{lstlisting}
Compare how C and Java deal with this problem:\\
	\indent C -- undefined behavior\\
	\indent Java -- L $\to$ R semantics; this is valid, but prevents compiler optimization.\\
We can thus see side effects in expressions tend to be bad news, and programs with them are hard to maintain.\\
\textbf{\underline{Undefined Behavior}} is dependent on semantics; it is the problem of competing side effects\\
\\
These problems were evident to J. Backus after he made FORTAN ambiguous for performance's sake.\\
He regretted it, and thus proposed \textbf{\underline{functional programming}}\\
He had two primary motivations in doing this: \begin{enumerate}[itemsep=0mm]
	\item clarity (use of well defined math notation)\\
		even the name of an imperative language (C++ -> C = C + 1) is nonsense!
	\item performance (via parallelization)\\
		escape the von Neumann LOAD-EXECUTE-STORE model
	\end{enumerate}

\noindent One can now see Backus was a visionary: \begin{enumerate}[itemsep=0mm]
	\item IOT devices occasionally recompute a value rather than load from RAM to save power.
	\item RAM access can have massive time cost when distance separated from CPU
	\item modern computers run many CPU's in parallel
	\end{enumerate}
This makes his paradigm worth discussing, but some terms need to be defined first:\\
	\indent \textbf{\underline{function}} $\equiv$ a mapping from a domain to a range\\
	\indent \textbf{\underline{domain}} $\equiv$ a set of values\\
	\indent \textbf{\underline{range}} $\equiv$ a set of values\\
	\indent \textbf{\underline{partial function}} $\equiv$ a function which maps a subset of the domain\\
	\indent \textbf{\underline{no side effects}} $\equiv$ 
		the same arguments to the same function will always the same result\\
	\indent \textbf{\underline{functional form/higher-order function}} $\equiv$
		a function with a function as a parameter\\
\\
So if functional languages can't modify state, how do they do I/O?\\
	\indent The short answer? They don't; it can't be done functionally. \\
	\indent The long answer? Consider getc().  It moves the stream pointer, so it has side effects.\\
	\indent \indent We can thus emulate a pure functional I/O function by \begin{lstlisting}[language=ML]
	define (f1, c) = getc(f) \end{lstlisting}
Functional programming has a few very beneficial properties: \begin{lstlisting}[language=ML]
(* 1. evaluation order is not controlled by sequencing *)
# h(f(a), g(b))
	(* the order must be g,f -> h; since g \& f have no order, this is partial order *)
(* 2. referential transparency *)
# 	let x = 1 in
	let f = fun f -> x + f in 
	let x = 2 in
	f 2;;
- : int 3
(* 	f uses the definition of x within its code block -- this x cannot change value.
	The variable/function f exist in different namespaces => they are unambiguous.
	Thus the CPU can cache and optimize even faster.
	This is so strong that there will be no errors, even on reuse: *)
# let square square = square * square;;
(* perfectly valid code -- function square \& variable square are in different namespaces *)
\end{lstlisting}
\end{document}