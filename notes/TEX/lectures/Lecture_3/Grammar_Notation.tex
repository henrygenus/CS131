\documentclass[../../lecture_notes.tex]{subfiles}

\begin{document}

The basic form of notation for a context-free grammar is the \textbf{\underline{Backus-Nour Form}}.\\
These map non-terminal identifiers to their options for representation.\\
Consider the example BNF grammar:\\
\indent S $\rightarrow$ (S)\\
\indent S $\rightarrow$ a\\
A similar grammar can be expressed more efficiently in the form of a regular expression:\\
\indent S $\rightarrow$ ab*\\
But sadly, regular expressions cannot be used on just any grammar.\\
For example, in attempting to emulate the BNF grammar above, the closest we can come is (*a)*.\\
This does not account for matching parenthesis count!\\
This is because regular expressions cannot handle \underline{nested} recursion.\\
\\
Let's try to extend REGEX by merging with standard notation.\\
Consider the example of email-RFC5322.  This requires all emails contain a line similar to the following:
\begin{center} Message-ID:<eggert."93-5xx27"@cs.ucla.edu> \end{center}
This uniquely identifies any email message to allow for easy filtering of duplicates.\\
The grammar takes the form of an extended BNF.\\
It uses / for OR, * for repeatable nonterminals, () for optional, and '' for terminals:\\
\indent msg-id = '<' dot-atom-text '@' id-right '>'\\
\indent id-right = dot-atom-text / no-fold-literal\\
\indent dot-atom-text = 1*atext (. 1*atext)\\
\indent no-fold-literal = '[' *dtext ']'\\
\indent atext = ALPHA | DIGIT | '!' | '\#' | ...\\
\indent dtext = \%33-90 / \%94-126 (the set of printable characters excluding '[', '/', and '])\\
\\
Since this is an EBNF grammar, it must be expressible in BNF form.\\
Consider the fourth rule in the list.  It can be expressed in BNF form as the set of\\
	\indent no-fold-literal = '[' dtexts ']'\\
	\indent dtexts =\\
	\indent dtexts = dtext dtexts\\
We could perform similar expansion for the rest of the rules, but this would get unwieldy quick.\\
We thus need a more efficient form for expressing grammars.\\
Luckily, the International Standards Organization established a standard called \textbf{\underline{ISO BNF}}\\
\\
ISO-EBNF (a top-down view):\\
\indent "terminal symbol"\\
\indent [optional]\\
\indent {repeat zero or more times}\\
\indent *repeated\\
\indent (* comment *)\\
\indent A - B (* A except B, set division *)\\
\indent A,B (* concatenate A and B *)\\
\indent A|B (* A or B *)\\
\indent A = BC; (* grammar rule *)\\
The gave an English summary of their grammar for grammars, then demonstrated it with their own notation:\\
\indent syntax = syntax-rule , {syntax-rule};\\
\indent syntax-rule = meta-id , '=' , defns-list , ';' ;\\
\indent defns-list = defn , {'|' , defn};\\
\indent defn = term , {',' , term}\\
\indent term = factor , ['-' , exception];\\
\indent exception = factor;\\
\indent factor = [indeger , '*']\\
Note that exception is unnecessary, but was included for clarity.\\
\newpage

\noindent Some grammars, like SQL data typing extensions, 
	are best expressed through \textbf{\underline{syntax charts}}.\\
Here is an impractically small example (in SQL notation):\begin{center}
	<cond> $rightarrow$ (<cond clause>*) | (cond <cond clause>* (else <sequence>)) \end{center}
This is equivalent to the following diagram: \begin{center} \begin{tikzpicture}
	%nodes
		\node (1) {};
		\node[right =of 1](2) {(};
		\node[right =of 2] (3) {cond};
		\node[ellipse, draw, right =of 3] (4) {cond clause};
		\node[right =of 4] (5) {(};
		\node[right =of 5] (6) {else};
		\node[ellipse, draw, right =of 6] (7) {sequence};
		\node[right =of 7] (8) {)};
		\node[right =of 8] (9) {)};
		\node[right =of 9] (10) {};
	%arrows
		\draw [->] (1.east) -- (2.west);
		\draw [->] (2.east) -- (3.west);
		\draw [->] (3.east) -- (4.west);
		\draw [->] (4.east) -- (5.west);
		\draw [->] (5.east) -- (6.west);
		\draw [->] (6.east) -- (7.west);
		\draw [->] (7.east) -- (8.west);
		\draw [->] (8.east) -- (9.west);
		\draw [->] (9.east) -- (10.west);
		\draw [->] (3.north east) to [out=30, in=150] (5.north west);
		\draw [->] (5.south west) to [out=210, in=330] (3.south east);
\end{tikzpicture} \end{center}
We can use this to program a parser: \begin{lstlisting}[language=C]
void cond(void) {
	eat("(");
	eat("cond");
	while (cond-clause()) continue;
	eat(")");
	...
} \end{lstlisting}
It would be nice to be able to express this as a finite state machine, but there is recursion.\\
Thus we would need to use a push-down automaton to express this.\\
Grammars progress into programs along grammar $\rightarrow$ design $\rightarrow$ parser code\\
But code can be buggy, and bugs in the parser would be bugs in the grammar, adding to complication!

\subsection*{Grammar Issues}
\begin{enumerate} [itemsep=0mm]
	\item {Useless Rules}\\
		S $\rightarrow$ Sa\\
		S $\rightarrow$ B\\
		C $\rightarrow$ Cd\\
		While this is a valid grammar, it defines a pointless subroutine, wasting space.\\
		These errors can further be broken down into 
			\begin{enumerate} [itemsep=0mm]
				\item Nonterminal used but not defined\\
						S $\rightarrow$ Sa\\
						S $\rightarrow$ Bc\\
						S $\rightarrow$ d\\
					The second grammar rule above is analogous to calling an undefined subroutine.
				\item Nonterminal defined but not used\\
						S $\rightarrow$ Sa\\
						S $\rightarrow$ d\\
						B $\rightarrow$ aS\\
					The third grammar rule above is analogous to defining an uncalled function.
			\end{enumerate}
		While these are both valid grammars, they are space-inefficient.
	\item Uncaptured Constraints
		Consider the following subset of English:\\
			S $\rightarrow$ NP VP\\
			NP $\rightarrow$ N\\
			NP $\rightarrow$ Adj NP\\
			VP $\rightarrow$ V\\
			VP $\rightarrow$ VP Adv\\
			for tokens {N, V, Adj, Adv}\\
		This grammar has errors: for instance, it allows the sentence "Dog Bark".\\
		To account for subject-verb agreement, we must complicate the grammar.\\
		We would double the size of our grammar just to solve a boolean issue!\\
	\end{enumerate}
There are other types of errors, which would each cause exponential growth.\\
We can demonstrate some of these issues in OCaml:\\
\begin{lstlisting}[language=ML]
	let x=5 in x*y;; (* undefined y *)
	5 / 3.0;; (* error: bad type float *)
\end{lstlisting}
How do we fix these? WE DON'T.  DON'T DO IT.\\
\end{document}