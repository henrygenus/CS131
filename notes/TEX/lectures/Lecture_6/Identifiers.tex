\documentclass[../../lecture_notes.tex]{subfiles}

\begin{document}

\noindent In addition to hardware/software interface evolution, languages can evolve too.\\
Languages like C/C++ have evolved so much that programs from the 70s couldn't run today.\\
There are even "software archaeologists" who specialize in translating this code.\\
The point is, we have a compatibility issue that we need to plan to address.\\
\\
Let's consider some specific examples:
	\begin{itemize} [itemsep=0mm]
		\item BASIC:
			\begin{itemize} [itemsep=0mm]
				\item was developed for the GE model 225 CPU.  Specs:
					\begin{itemize} [itemsep=0mm]
						\item about 40 microseconds per addition, and 500 microseconds per division.
						\item about 40 KiB RAM, which was huge for the time.
							This is big enough that the device could fit all of BASIC in its RAM!
					\end{itemize}
				\item BASIC is a small base language which supports many extensions.
				\item While this was critical at the time due to limited memory, it is now inconsequential.
			\end{itemize}
		\item C
			\begin{itemize} [itemsep=0mm]
				\item was developed for the PDP II Minicomputer CPU.  Specs:
					\begin{itemize} [itemsep=0mm]
						\item about 4 microseconds per addition and 1.2 microsecond cycle time
						\item about 16 KiB RAM
					\end{itemize}
				\item C allows for fast memory access, but comparatively slow computation;\\
					This means that pointers were a very efficient way to manipulate data.
				\item Modern computers can do computation easily, but access RAM comparatively slowly.
			\end{itemize}
	\end{itemize}
These languages can still run on modern devices, but their performance is worse.\\
We can, however, anticipate these changes\\
\indent For instance, modern languages are not conducive to GPU (SIMD)/cloud computing (MIMD).\\
All of these issues are issues of \textbf{\underline{scale}}; languages may not scale well to:
	\begin{itemize} [itemsep=0mm]
		\item larger machines with increased array size and multiple CPUs
		\item complex problems that require multiple programmers
	\end{itemize}
We address these issues in a few object-oriented ways.\\

\subsubsection*{Names/Identifiers}
These are arbitrary within a program, so why is this the first thing we discuss?\\
\indent Choosing naming conventions is a major issue within software engineering.\\
There are two aspects to identifiers within a program:
\begin{itemize} [itemsep=0mm]
	\item Binding Time
	\item Scope
\end{itemize}
We face a couple common issues:
	\begin{enumerate} [itemsep=0mm]
		\item Permitted Characters
			\begin{itemize} [itemsep=0mm]
				\item In FORTAN, spaces were permitted within names.  This led to serious errors.\\
				In the code controlling the Mariner 1 rocket, the following code was intended
				\begin{lstlisting}[language=FORTRAN]
DO 10 I = 1,10
  FOO(I)
10 continue
				\end{lstlisting}
				but a period was typed instead of a comma, causing the code to be interpreted as
				\begin{lstlisting}[language=FORTRAN]
DO 10 I = 1.10
FOO(I)
				\end{lstlisting}
				This resulted in the crashing of the rocket!
			\item In C++, an identifier is of the form [a-zA-z\_][a-zA-Z\_0-9]*\\
				Characters from other languages were initially prohibited, but this changed in C++11\\
				This added complexity, since the latin and Cyrillic o's look similar but are encoded uniquely.\\
				Additionally, only some parts of names are case sensitive:
				\begin{lstlisting} [language=C++]
double e = 1e16;
double E = 1E16;
assert(e == E > memcmp(e, E, sizeof(e)));
				\end{lstlisting}
			\end{itemize}
		\item Reserved Words
			\begin{lstlisting} [language=C++]
if (class < 12) return; // legal in C, not in C++
			\end{lstlisting}
			Clearly, adding keywords to a language can add complexity and invalidate legacy code.\\
			We thus reserve names early in a language's development.\\
			For example, C/C++ reserve names starting with '\_',  so \_Noreturn could safely be added in C11.\\
		\end{enumerate}

\subsubsection*{Binding}
$\equiv$ an association between a name and a value.\\
We often access bound data via its mapping in the symbol table.  These bindings can be deceptively simple:
\begin{lstlisting} [language=C++]
short a = 10; // a is bound to 10
short *p = &a; // pointer is bound to the address of a
assert(int *p = &10); // ERROR: literals do not have memory addresses
assert(sizeof{10} = sizeof(a)); // NO -- 10 is 4 bytes but a is only one
\end{lstlisting}
Binding is done in one of two ways:
\begin{enumerate} [itemsep=0mm]
	\item \textbf{\underline{Explicit Binding}} $\equiv$ binding written directly into a program
	\item \textbf{\underline{Implicit Binding}} $\equiv$ binding done as a consequence of a program
\end{enumerate}
Implicit binding is often considered bad practice, so explicit binding is often encouraged.\\
In many languages, types must be declared explicitly so as to avoid errors.\\
These languages bind variables to values between compilation and linkage, 
	in a time called \textbf{\underline{binding time}}.\\
To understand the different periods of binding, consider the following code:
\begin{lstlisting} [language=C++]
void main() 
{
  for (int i = 0; i < 10; i++) foo(i);
}
\end{lstlisting}
Portions of this function were bound at different times (listed chronologically):
\begin{enumerate} [itemsep=0mm]
	\item 'void' and 'for' were bound at language \textbf{\underline{definition/authorship time}}
	\item 'int' was bound to 4/8/etc bytes at \textbf{\underline{language implementation time}}
	\item 'foo' was bounded to its definition and reference at \textbf{\underline{link time}}
	\item 'foo' and 'main' were bounded to their memory locations at \textbf{\underline{load time}}
	\item 'i' is bounded to multiple values at \textbf{\underline{runtime}}
\end{enumerate}
Even with the support for explicit binding, even C cannot avoid it completely.\\
Macros are expanded prior to runtime, but allow for implicit binding like so:
\begin{lstlisting}[language=C++]
#define Foo 27
#IFDEF FOO ...
// if we typed FO0 instead, 
// we would get no error, 
// but the if branch would be skipped
\end{lstlisting}
OCaml is considered a safer language than C, but OCaml uses nearly all implicit binding.\\
How is this possible?  OCaml is safe because of redundancy and type checking.\\
We can do this in gcc with an option which bans implicit binding \\
\indent BUT even that wouldn't fix the above issue.\\

\subsubsection*{Types}
Finding an exact definition of types is difficult, so we will use a few.  This is the simplest:\\
\indent $\equiv$ a set of values/objects\\
Defining a type explicitly via listing is called \textbf{\underline{enumeration}},
	and is used in functional languages like Lisp.
In computer languages, these enumerations are often defined in terms of \textbf{\underline{native types}}.\\
Any type that can be constructed of native types is called a \textbf{\underline{constructed type}}.
\\
Object-Oriented languages often use another definition:\\
\indent $\equiv$ a set of values and a set of operations on those values\\
Adding the idea of operations allows for observation of values and performance of actions; consider:
\begin{lstlisting} [language=C++]
class complex 
{
  double re;
  double im;
  double dist() {return sqrt(re*re + im*im);}
}
\end{lstlisting}
The above definitions can be used to analyze the C primitive 'float':
\begin{itemize} [itemsep=0mm]
	\item is float a set of values? YES -- {0, 0.2, 0.22, ...}
	\item is float a representation? YES -- defined as follows:
\end{itemize} 
For many years, this implementation was hidden;\\
	since not specified by the spec, implementations tended to be machine-dependent.\\
In the current day, one layout has won out, called IEEE-754:\\
\indent Numbers are 32 bits, and represented by the following sequential sections:
	\begin{enumerate} [itemsep=0mm]
		\item the sign bit
		\item the eight bit exponent value
		\item the 23 bit fractional value
	\end{enumerate}
We interpret the float value $(sef)$ according to the following rule:
	\begin{equation*}
		\text{value}(sef) = \left\{ \begin{array} {lr}
				(-1)^s * 2^{e - 127} * 1.f & \text{ for } o < e < 255 \text{(normalized)}\\
				(-1)^s * 2^{e - 127} * 0.f & \text{ for } e = 0 \text{ (denormalized)}\\
				(-1)^s * \infty & \text{ for } e=255 \text{ \&\& } f = 0\\
				\text{ Not a Number (NaN) } & \text{ for } e = 255 \text{ \&\& } f != 0
			\end{array} \right\}
	\end{equation*}
This implementation results in a couple special cases:
\begin{itemize} [itemsep=0mm]
	\item there are two distinct zeroes\\
		$\rightarrow$  two variables can have different data with the same value.
	\item NaN evaluates false no matter what it is compared with\\
		$\rightarrow$ two variables can have the same data and different values.
\end{itemize}
Floats can trigger a few exceptions:
\begin{enumerate} [itemsep=0mm]
	\item overflow -- exponent too large (1e308 x 1e308)
	\item underflow -- exponent too small (1e-307 x 1e-307)
	\item bad arguments -- (0.0/0.0, sqrt(-1))
	\item inexact results -- (1.0/10 != 0.1)
\end{enumerate}
Traditionally, hardware would trap on exceptions 1-3 and ignore 4, but now they all return special values.\\
\\
Types have a few ways to avoid exceptions:
\begin{itemize} [itemsep=0mm]
	\item \textbf{\underline{Annotations}}\\
		Types document programs, and the compiler uses this documentation to report errors. (ex. int val;)\\
	\item \textbf{\underline{Inference}}\\
		The compiler infers the type from the code (ex. 1.0, 1.0f, 1)\\
		There are two standard approaches:
		\begin{itemize} [itemsep=0mm]
			\item bottom-up -- C: 3 + 4.5 + 'a' $\rightarrow$ float
			\item top-down -- OCaml: [3, 4, 5] = (f y z) $\rightarrow$ int -> int -> int
		\end{itemize}
	\item \textbf{\underline{Checking}}\\
		In a strongly typed language, all operations are checked for type matches prior to being run.\\
		The benefits: it is safer, and there is no mistaking the type.\\
		The downsides: it is finicky, and can disallow legal operations.\\
		C and C++ are strongly typed (except void pointers can subvert this typing).\\
		OCaml and Java are strongly typed with no exceptions.\\
		Python is weakly typed with no exceptions.
\end{itemize} 
\end{document}